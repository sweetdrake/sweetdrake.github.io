<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="kr"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://sweetdrake.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://sweetdrake.github.io/" rel="alternate" type="text/html" hreflang="kr"/><updated>2024-06-25T05:38:58+00:00</updated><id>https://sweetdrake.github.io/feed.xml</id><title type="html">Learning by doing</title><subtitle></subtitle><entry><title type="html">gpt와 춤을, MACSec 예제 뿌수기</title><link href="https://sweetdrake.github.io/blog/2024/Macsec_GCM/" rel="alternate" type="text/html" title="gpt와 춤을, MACSec 예제 뿌수기"/><published>2024-06-24T09:14:00+00:00</published><updated>2024-06-24T09:14:00+00:00</updated><id>https://sweetdrake.github.io/blog/2024/Macsec_GCM</id><content type="html" xml:base="https://sweetdrake.github.io/blog/2024/Macsec_GCM/"><![CDATA[<p>IEEE 802.1AE 2018 MAC(Media access control)은 autumotive MACSec가 참고하는 표준 문서 입니다. 802.1AE 에서 예제가 나와있는데, 잘 이해가 안 가서 python을 통해 값을 유도하는 코드를 작성했습니다. gpt로 예제 해석해달라고 하니까 코드까지 만들어주는 세상이네요..</p> <p>gpt3.5로 생성한 코드이고 중간마다 padding이 깨지고, 출력값이 missing나는 경우도 있었지만, 고쳐달라고 다시 타이핑 해주니 뚝딱뚝딱 고쳐버리는 AI입니다. <del>(Nvidia/MS 만세)</del> 짧은 시간 대비 아웃풋이 정말 잘 나온 것 같아서.. 놀랍네요</p> <p>코드는 제 github <a href="https://github.com/sweetdrake/MACSec_GCM_AES">MACSec_GCM_AES</a>에 올려두었습니다.</p> <p>블로그에서 jupyter가 지원되서 jupyter로 올려봅니다</p> <h4 id="jupyter-코드">Jupyter 코드</h4> <div class="jupyter-notebook" style="position: relative; width: 100%; margin: 0 auto;"> <div class="jupyter-notebook-iframe-container"> <iframe src="/assets/jupyter/blog.ipynb.html" style="position: absolute; top: 0; left: 0; border-style: none;" width="100%" height="100%" onload="this.parentElement.style.paddingBottom = (this.contentWindow.document.documentElement.scrollHeight + 10) + 'px'"></iframe> </div> </div> <h4 id="table-c-9-refer-to-ieee-std-8021ae">Table C-9, refer to IEEE std 802.1AE</h4> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-06-224-Masec_GCM_tableC9.JPG-480.webp 480w,/assets/img/2024-06-224-Masec_GCM_tableC9.JPG-800.webp 800w,/assets/img/2024-06-224-Masec_GCM_tableC9.JPG-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2024-06-224-Masec_GCM_tableC9.JPG" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div>]]></content><author><name></name></author><category term="개발"/><category term="삽질"/><category term="python"/><summary type="html"><![CDATA[gpt를 사용해 python GCM-AES-128 코드를 작성해 Macsec 예제를 이해합니다]]></summary></entry><entry><title type="html">서양의 개발 용어</title><link href="https://sweetdrake.github.io/blog/2024/devTerminology/" rel="alternate" type="text/html" title="서양의 개발 용어"/><published>2024-06-19T09:14:00+00:00</published><updated>2024-06-19T09:14:00+00:00</updated><id>https://sweetdrake.github.io/blog/2024/devTerminology</id><content type="html" xml:base="https://sweetdrake.github.io/blog/2024/devTerminology/"><![CDATA[<p>소개하는 용어는 사용하는 집단에 따라 틀릴 수도 있음</p> <p>쓰고보니 많지 않네..</p> <h4 id="용어-모음">용어 모음</h4> <table data-toggle="table" data-url="/assets/json/devterm.json"> <thead> <tr> <th data-field="Term">Term</th> <th data-field="Description">Description</th> <th data-field="Example">Example</th> <th data-field="Translation">Translation</th> </tr> </thead> </table>]]></content><author><name></name></author><category term="개발"/><category term="삽질"/><category term="links"/><summary type="html"><![CDATA[이건 영어로 뭐라고 하지 싶은 개발 관련 용어]]></summary></entry><entry><title type="html">ssh python 삽질기록</title><link href="https://sweetdrake.github.io/blog/2024/ssh_experiment/" rel="alternate" type="text/html" title="ssh python 삽질기록"/><published>2024-06-17T09:14:00+00:00</published><updated>2024-06-17T09:14:00+00:00</updated><id>https://sweetdrake.github.io/blog/2024/ssh_experiment</id><content type="html" xml:base="https://sweetdrake.github.io/blog/2024/ssh_experiment/"><![CDATA[<p>powershell script를 통해 remote access를 수행하고<br/> MobaXterm의 기능인 ssh gateway (jump host)를 python으로 구현해봅니다.</p> <h4 id="overview">Overview</h4> <p>회사에서 서로 다른 사용자들이 빌드서버에 접속 / 공용 리모트 컴퓨터(Windows)에 접속해서 테스트할 일이 꽤 많은데, 빌드서버에서 빌드 이미지를 개인 PC로 가져오는 것도 귀찮고, 리모트 컴퓨터에 접속하면 상대방이 튕기는 여러 불편함이 많아 이를 해결하기 위한 툴을 만들었다.</p> <p>해당 포스트에서 소개하는 내용은,</p> <ol> <li>JSON으로 개인 보안 정보가 담긴 외부 파일을 만들어 각자 관리하고, (MyConfig.json)</li> <li>파이썬을 통해 SSH server가 설치된 ubuntu 빌드 서버에 접속, 파일 가져오기 그리고 가져온 파일을 공유 폴더에 올리고, (sshClient.py)</li> <li>Powershell을 통해 remote desktop에 명령을 내린다. 명령은 remote desktop에 있는 test.py를 실행하기 위한 목적. (command.ps1)</li> <li>remote desktop의 test.py은 연결된 target device로 공유 폴더의 바이너리 파일을 복사 후 실행한다. (test.py)</li> </ol> <p>간단히 도식화하면 아래와 같다.</p> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-06-18-ssh_experiment_overview.JPG-480.webp 480w,/assets/img/2024-06-18-ssh_experiment_overview.JPG-800.webp 800w,/assets/img/2024-06-18-ssh_experiment_overview.JPG-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2024-06-18-ssh_experiment_overview.JPG" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <h4 id="1-myconfigjson">[1] MyConfig.json</h4> <p><code class="language-plaintext highlighter-rouge">MyConfig.json</code>이라는 파일을 아래와 같이 생성</p> <pre><code class="language-JSON">{
  "config":{
    "User": "YOUR_ACCOUNT_NAME",
    "SSHServer": "YOUR_SSH_IP",
    "PassWord": "YOUR_PASSWORD",
    "BuildImagePath": "YOUR_BUILDIMAGE_PATH",
    "SharedPath" : "YOUR_SHARED_PATH"
  }
}
</code></pre> <p>파이썬으로 config정보가 담긴 파일을 로드<br/> (c_XXX등 으로 관리하면 헷갈려서 클래스로 관리하는데 여기서는 귀찮으니까 그냥 c_XXX로 네이밍함)</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">json</span>
<span class="k">def</span> <span class="nf">readJSON</span><span class="p">(</span><span class="n">config_file</span><span class="p">):</span>
    <span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="n">config_file</span><span class="p">,</span> <span class="sh">"</span><span class="s">r</span><span class="sh">"</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">json</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

<span class="n">config</span> <span class="o">=</span> <span class="nf">readJSON</span><span class="p">(</span><span class="sh">"</span><span class="s">MyConfig.json</span><span class="sh">"</span><span class="p">)</span>

<span class="n">c_user</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="sh">'</span><span class="s">config</span><span class="sh">'</span><span class="p">][</span><span class="sh">'</span><span class="s">User</span><span class="sh">'</span><span class="p">]</span>
<span class="n">c_sshServer</span>  <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="sh">'</span><span class="s">config</span><span class="sh">'</span><span class="p">][</span><span class="sh">'</span><span class="s">SSHServer</span><span class="sh">'</span><span class="p">]</span>
<span class="n">c_passWord</span>   <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="sh">'</span><span class="s">config</span><span class="sh">'</span><span class="p">][</span><span class="sh">'</span><span class="s">PassWord</span><span class="sh">'</span><span class="p">]</span>
<span class="n">c_buildImagePath</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="sh">'</span><span class="s">config</span><span class="sh">'</span><span class="p">][</span><span class="sh">'</span><span class="s">BuildImagePath</span><span class="sh">'</span><span class="p">]</span>
<span class="n">c_sharedPath</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="sh">'</span><span class="s">config</span><span class="sh">'</span><span class="p">][</span><span class="sh">'</span><span class="s">SharedPath</span><span class="sh">'</span><span class="p">]</span>
</code></pre></div></div> <h4 id="2-sshclientpy">[2] sshClient.py</h4> <p>config 정보를 바탕으로 SSH client를 통해 build server(SSH server)에 접속 후 이미지 파일을 공유 폴더로 복사하는 코드</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">paramiko</span>

<span class="k">def</span> <span class="nf">printTotals</span><span class="p">(</span><span class="n">transferred</span><span class="p">,</span> <span class="n">toBeTransferred</span><span class="p">):</span><span class="c1">#복사한 image 파일 크기 출력
</span>    <span class="nf">if</span><span class="p">(</span><span class="n">transferred</span> <span class="o">==</span> <span class="n">toBeTransferred</span><span class="p">):</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Transferred </span><span class="si">{</span><span class="n">c_buildImagePath</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="sh">'</span><span class="s">/</span><span class="sh">'</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s"> file </span><span class="si">{</span><span class="n">transferred</span><span class="o">/</span><span class="p">(</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">)</span><span class="si">:</span><span class="p">.</span><span class="mi">2</span><span class="n">f</span><span class="si">}</span><span class="s">MB to </span><span class="si">{</span><span class="n">c_sharedPath</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>

<span class="n">buildserver_ssh</span> <span class="o">=</span> <span class="n">paramiko</span><span class="p">.</span><span class="nc">SSHClient</span><span class="p">()</span>
<span class="n">buildserver_ssh</span><span class="p">.</span><span class="nf">set_missing_host_key_policy</span><span class="p">(</span><span class="n">paramiko</span><span class="p">.</span><span class="nc">AutoAddPolicy</span><span class="p">())</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">buildserver_ssh</span><span class="p">.</span><span class="nf">connect</span><span class="p">(</span><span class="n">c_sshServer</span><span class="p">,</span> <span class="n">username</span><span class="o">=</span><span class="n">c_user</span><span class="p">,</span> <span class="n">password</span><span class="o">=</span><span class="n">c_passWord</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Connection established ...</span><span class="si">{</span><span class="n">c_sshServer</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
    <span class="n">sftp</span> <span class="o">=</span> <span class="n">buildserver_ssh</span><span class="p">.</span><span class="nf">open_sftp</span><span class="p">()</span>
    <span class="n">sftp</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">c_buildImagePath</span><span class="p">,</span>
    <span class="n">c_sharedPath</span><span class="o">+</span><span class="n">c_buildImagePath</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="sh">'</span><span class="s">/</span><span class="sh">'</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="c1">#bulidImage를 shared path에 복사
</span>        <span class="n">callback</span><span class="o">=</span><span class="n">printTotals</span><span class="p">)</span>
<span class="k">except</span> <span class="n">paramiko</span><span class="p">.</span><span class="n">AuthenticationException</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Failed to authenticate.</span><span class="sh">"</span><span class="p">)</span>
<span class="k">except</span> <span class="nb">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">An error occurred: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="k">if</span> <span class="sh">'</span><span class="s">sftp</span><span class="sh">'</span> <span class="ow">in</span> <span class="nf">locals</span><span class="p">():</span>
    <span class="n">sftp</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>
    <span class="n">buildserver_ssh</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>
</code></pre></div></div> <h4 id="3-myconfigjson">[3] MyConfig.json</h4> <p>Remote desktop에 명령을 내리는 Powershell script, <code class="language-plaintext highlighter-rouge">command.ps1</code> <br/> 아래 <code class="language-plaintext highlighter-rouge">command.ps1</code>을 실행하기 위해서는 PsExec.exe 파일이 있어야한다. MS에서 제공하는 utility로 Windows remote access를 지원한다. 다운로드와 자세한 내용은 <a href="https://learn.microsoft.com/en-us/sysinternals/downloads/psexec">MS 내 PsExec 소개 페이지</a>를 참고</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.<span class="se">\P</span>sExec.exe <span class="nt">-i</span> <span class="se">\\</span>YOUR_REMOTE_IP <span class="nt">-u</span> YOUR_REMOTE_ACCOUNT <span class="nt">-p</span> YOUR_PASSWORD cmd /c python3 test.py 2&gt;<span class="nv">$null</span>
</code></pre></div></div> <p>근데 PsExec를 powershell에서 단독으로 사용하면 cmd 결과가 출력되는데, python으로 powershell을 실행하여 위 <code class="language-plaintext highlighter-rouge">command.ps1</code>을 실행하면 결과가 안나온다. 커맨드 실행 결과가 출력되지 않고 실행 여부가 출력됨 :cry:</p> <p>그래서 remote desktop에 있는 test.py를 통해 공유폴더에 log를 남기고, <code class="language-plaintext highlighter-rouge">command.ps1</code>를 실행한 컴퓨터 쪽에서 log를 확인하는 식으로 활용함.</p> <p>아래는 python 내에서 powershell을 통해 <code class="language-plaintext highlighter-rouge">command.ps1</code>을 실행하는 코드<br/> (위 서술한 log가 실시간으로 출력되지 않아, 아래 python은 실행안하고 그냥 powershell로 확인하는 경우가 더 많았음)</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">subprocess</span> <span class="k">as</span> <span class="n">sp</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">sp</span><span class="p">.</span><span class="nc">Popen</span><span class="p">([</span><span class="sh">'</span><span class="s">powershell.exe</span><span class="sh">'</span><span class="p">,</span> <span class="sh">"</span><span class="s">YOURPATH</span><span class="se">\\</span><span class="s">command.ps1</span><span class="sh">"</span><span class="p">,</span> <span class="p">],</span> <span class="n">shell</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">stdout</span><span class="o">=</span><span class="n">sp</span><span class="p">.</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">stderr</span><span class="o">=</span><span class="n">sp</span><span class="p">.</span><span class="n">PIPE</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">res</span><span class="p">.</span><span class="n">stderr</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">res</span><span class="p">.</span><span class="n">stdout</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
<span class="k">except</span> <span class="nb">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Exception </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <h4 id="4-testpy">[4] test.py</h4> <p>마지막 remote desktop내에서 타겟 디바이스의 ssh–&gt; ssh –&gt; 바이너리 실행하는 파이썬 코드</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">paramiko</span>
<span class="kn">import</span> <span class="n">os</span>

<span class="k">def</span> <span class="nf">upload_directory</span><span class="p">(</span><span class="n">sftp</span><span class="p">,</span> <span class="n">local_dir</span><span class="p">,</span> <span class="n">device_dir</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">os</span><span class="p">.</span><span class="nf">listdir</span><span class="p">(</span><span class="n">local_dir</span><span class="p">):</span>
        <span class="nf">print</span><span class="p">(</span><span class="n">os</span><span class="p">.</span><span class="nf">listdir</span><span class="p">(</span><span class="n">local_dir</span><span class="p">))</span>
        <span class="n">local_path</span> <span class="o">=</span> <span class="n">local_dir</span> <span class="o">+</span> <span class="sh">"</span><span class="se">\\</span><span class="sh">"</span> <span class="o">+</span> <span class="n">filename</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">sftp</span><span class="p">.</span><span class="nf">chdir</span><span class="p">(</span><span class="n">device_dir</span><span class="p">)</span>
        <span class="k">except</span> <span class="nb">IOError</span><span class="p">:</span>
            <span class="n">sftp</span><span class="p">.</span><span class="nf">mkdir</span><span class="p">(</span><span class="n">device_dir</span><span class="p">)</span>
            <span class="n">sftp</span><span class="p">.</span><span class="nf">chdir</span><span class="p">(</span><span class="n">device_dir</span><span class="p">)</span>
        <span class="n">sftp</span><span class="p">.</span><span class="nf">put</span><span class="p">(</span><span class="n">local_path</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">copied file </span><span class="si">{</span><span class="n">local_path</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>

<span class="n">ssh</span> <span class="o">=</span> <span class="n">paramiko</span><span class="p">.</span><span class="nc">SSHClient</span><span class="p">()</span>
<span class="n">ssh</span><span class="p">.</span><span class="nf">set_missing_host_key_policy</span><span class="p">(</span><span class="n">paramiko</span><span class="p">.</span><span class="nc">AutoAddPolicy</span><span class="p">())</span>

<span class="k">try</span><span class="p">:</span>
    <span class="n">ssh</span><span class="p">.</span><span class="nf">connect</span><span class="p">(</span><span class="sh">'</span><span class="s">YOUR_SSH1_IP</span><span class="sh">'</span><span class="p">,</span> <span class="n">username</span><span class="o">=</span><span class="sh">'</span><span class="s">YOUR_SSH1_ID</span><span class="sh">'</span><span class="p">,</span> <span class="n">password</span><span class="o">=</span><span class="sh">'</span><span class="s">YOUR_SSH1_PW</span><span class="sh">'</span><span class="p">)</span>
    <span class="n">jump_transport</span> <span class="o">=</span> <span class="n">ssh</span><span class="p">.</span><span class="nf">get_transport</span><span class="p">()</span>
    <span class="n">channel</span> <span class="o">=</span> <span class="n">jump_transport</span><span class="p">.</span><span class="nf">open_channel</span><span class="p">(</span><span class="sh">"</span><span class="s">direct-tcpip</span><span class="sh">"</span><span class="p">,</span> <span class="p">(</span><span class="sh">'</span><span class="s">YOUR_SSH2_IP</span><span class="sh">'</span><span class="p">,</span> <span class="mi">22</span><span class="p">),</span> <span class="p">(</span><span class="sh">'</span><span class="s">YOUR_SSH1_IP</span><span class="sh">'</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
    <span class="n">target_ssh</span> <span class="o">=</span> <span class="n">paramiko</span><span class="p">.</span><span class="nc">SSHClient</span><span class="p">()</span>
    <span class="n">target_ssh</span><span class="p">.</span><span class="nf">set_missing_host_key_policy</span><span class="p">(</span><span class="n">paramiko</span><span class="p">.</span><span class="nc">AutoAddPolicy</span><span class="p">())</span>
    <span class="n">target_ssh</span><span class="p">.</span><span class="nf">connect</span><span class="p">(</span><span class="sh">'</span><span class="s">YOUR_SSH2_IP</span><span class="sh">'</span><span class="p">,</span> <span class="n">username</span><span class="o">=</span><span class="sh">'</span><span class="s">YOUR_SSH2_ID</span><span class="sh">'</span><span class="p">,</span> <span class="n">password</span><span class="o">=</span><span class="sh">'</span><span class="s">YOUR_SSH2_PW</span><span class="sh">'</span><span class="p">,</span> <span class="n">sock</span><span class="o">=</span><span class="n">channel</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Connection established ...</span><span class="sh">"</span><span class="p">)</span>

    <span class="n">sftp</span> <span class="o">=</span> <span class="n">target_ssh</span><span class="p">.</span><span class="nf">open_sftp</span><span class="p">()</span>

    <span class="c1"># move TEST_BINARY to TAEGET_DEVICE_PATH
</span>    <span class="n">local_dir</span> <span class="o">=</span> <span class="n">os</span><span class="p">.</span><span class="nf">getcwd</span><span class="p">()</span> <span class="o">+</span> <span class="sh">"</span><span class="se">\\</span><span class="s">TEST_BINARY</span><span class="sh">"</span> <span class="c1"># Remote desktop
</span>    <span class="n">device_dir</span> <span class="o">=</span> <span class="sh">"</span><span class="s">/TARGET_DEVICE_PATH</span><span class="sh">"</span>        <span class="c1"># PATH in Target device
</span>    <span class="nf">upload_directory</span><span class="p">(</span><span class="n">sftp</span><span class="p">,</span> <span class="n">local_dir</span><span class="p">,</span> <span class="n">device_dir</span><span class="p">)</span>

    <span class="c1"># commands to run on TARGET_DEVICE
</span>    <span class="n">commands</span> <span class="o">=</span> <span class="p">[</span>
        <span class="sh">'</span><span class="s">date</span><span class="sh">'</span><span class="p">,</span>
        <span class="sh">'</span><span class="s">chmod +x /TARGET_DEVICE_PATH/TEST_BINARY</span><span class="sh">'</span><span class="p">,</span>
      <span class="c1">#  './TARGET_DEVICE_PATH/TEST_BINARY'
</span>    <span class="p">]</span>
    <span class="k">for</span> <span class="n">command</span> <span class="ow">in</span> <span class="n">commands</span><span class="p">:</span>
        <span class="n">stdin</span><span class="p">,</span> <span class="n">stdout</span><span class="p">,</span> <span class="n">stderr</span> <span class="o">=</span> <span class="n">target_ssh</span><span class="p">.</span><span class="nf">exec_command</span><span class="p">(</span><span class="n">command</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">stdout</span><span class="p">.</span><span class="nf">read</span><span class="p">().</span><span class="nf">decode</span><span class="p">().</span><span class="nf">strip</span><span class="p">()</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">Output of </span><span class="si">{</span><span class="n">command</span><span class="si">}</span><span class="s">: </span><span class="si">{</span><span class="n">output</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
<span class="k">except</span> <span class="n">paramiko</span><span class="p">.</span><span class="n">AuthenticationException</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Failed to authenticate.</span><span class="sh">"</span><span class="p">)</span>
<span class="k">except</span> <span class="nb">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">An error occurred: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="k">if</span> <span class="sh">'</span><span class="s">sftp</span><span class="sh">'</span> <span class="ow">in</span> <span class="nf">locals</span><span class="p">():</span>
        <span class="n">sftp</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>
    <span class="n">target_ssh</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>
    <span class="n">ssh</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="개발"/><category term="삽질"/><category term="sidebar"/><category term="python"/><summary type="html"><![CDATA[ssh로 host간 jump를 사용해보자]]></summary></entry><entry><title type="html">나 혼자 회사에서 웨폰마스터</title><link href="https://sweetdrake.github.io/blog/2024/myToolList/" rel="alternate" type="text/html" title="나 혼자 회사에서 웨폰마스터"/><published>2024-05-30T09:14:00+00:00</published><updated>2024-05-30T09:14:00+00:00</updated><id>https://sweetdrake.github.io/blog/2024/myToolList</id><content type="html" xml:base="https://sweetdrake.github.io/blog/2024/myToolList/"><![CDATA[<p>나 혼자 레벨업, 나 혼자 탑에서 농사 등 나 혼자~ 물에 영감을 받아 제목을 지었습니다.</p> <p>사용하는 utility tool에 대해서 소개합니다.</p> <h2 id="powertoys-robot">Powertoys :robot:</h2> <p>MS에서 배포하는 툴로 여러 기능이 담겨 있다. 자세한 기능 소개는 <a href="https://learn.microsoft.com/ko-kr/windows/powertoys">Powertoys</a> 공식 사이트 참고.</p> <p>가장 많이 쓰는 기능은 마우스 유틸리티 기능, Mac에 있는 spotlight 처럼 빠른 실행을 하는 기능, Shortcut guide가 있다.</p> <h3 id="마우스-유틸리티">마우스 유틸리티</h3> <p>마우스 찾기는 날이 갈수록 넓어지는 모니터에서 마우스 찾기를 도와준다.</p> <p>또 Teams 같이 화면공유로 회의할 때, 하이라이트 해주는 목적으로도 활용한다. (근데 보는 쪽에서는 화면 공유 딜레이 땜에 렉걸린 줄 아는게 함정)</p> <p>마우스 형광펜 기능 또한 화면 녹화 등에 유용하다.</p> <h3 id="powertoys-run">PowerToys Run</h3> <p>익숙해지면 편한 기능, MAC의 spotlight과 유사하다. Installer를 통해 설치된 전역 파일의 경우 왠만하면 대부분 찾기가 가능한데, 특정 실행파일을 run 창에 띄우고 싶은 경우가 종종 있다. 그런 경우 등록하고 싶은 프로그램의 바로가기를 만든 뒤에 <code class="language-plaintext highlighter-rouge">해당 경로</code>에 바로가기 파일(shortcut)을 넣어주면 된다.</p> <p>여러가지 접미사를 두고 실행하는 기능도 있다. run 실행하면 창에 도움말이 뜨니까 몇 번 사용해보다가 쓰는 것만 쓰게 되는데 내 경우 <code class="language-plaintext highlighter-rouge">?? 검색어</code>를 제일 많이 쓴다. 기능은 웹 브라우저로 검색</p> <p>여러가지 플러그인도 지원하니 설치하는 재미가 있다. github emoji도 깔아서 쓰고있는데 github.io블로그에 alias로 이모지를 넣으니 직접 넣는 것보다 깔끔하니 보기 좋다.</p> <ul> <li>github alias로 emoji 출력 : :earth_asia:</li> <li>Raw emoji로 출력 🌏</li> </ul> <p>잡담으로 Windows에서 <code class="language-plaintext highlighter-rouge">Win key</code> + <code class="language-plaintext highlighter-rouge">.</code>으로 Emoji 패널을 띄울 수 있는데, 영어 키보드(US)에서만 이모지에 대한 검색이 가능하다. 한글 키보드의 경우 패널 상에 검색하는 기능이 없다. <del>(Windows 11에서는 되는 듯..)</del> github emoji 깔면 번거롭게 키보드 스위칭(<code class="language-plaintext highlighter-rouge">Win key</code> + <code class="language-plaintext highlighter-rouge">space</code>)할 필요가 없다.</p> <h3 id="shortcut-guide">Shortcut guide</h3> <p>Windows 버튼을 누르고 있으면 Windows OS에서 제공하는 단축키와 설명이 적힌 창이 올라온다.</p> <p>가끔 단축키가 긴가민가할 때 사용한다.</p> <h2 id="keyexplorer-closed_lock_with_key">KeyExplorer :closed_lock_with_key:</h2> <p>openssl 커맨드로 딥하게 볼 수 있겠지만, 항상 커맨드가 뭐였지 하고 구글링하게 된다.</p> <p>이 툴은 간단하게 인증서 파일이나 키 파일 열기, 다른 포맷으로 출력하고 싶을 때 주로 사용하는데, GUI도 지원하기 때문에 간단하게 drag-and-drop으로 끌어다 놓기만 하면 알아서 key file의 내용을 띄워준다. 가끔 포맷이 안 맞는 경우가 있어서 이런 경우 openssl로 까보는게 좋다.</p> <h2 id="everything-mag">Everything :mag:</h2> <p>Windows OS의 file searching 기능은 너무 느리고 쓰기도 불편하다.</p> <p>가령 어떤 파일을 찾아야하는데 확장자만 기억한다거나.. 어느 폴더 쯤에 있는지는 아는데 정확히 모른다거나.. 아니면 파일 이름 몇개만 기억한다 든지 하는 상황에서 쓰는 최고의 툴이다. (Unix에 find가 있다면 Windows에는 everything이 있다!!)</p> <p>정규표현식을 지원하기 때문에 *.pdf 이런식으로 검색해도 되고,</p> <p>특정 위치에서 파일 찾기는 폴더 우클릭으로 context 메뉴를 열어서 search everything.. 으로 검색하면 해당 폴더를 기준으로 파일 검색을 지원한다. (설치할 때 context 메뉴 추가하기 체크박스가 체크 되어있어야함)</p> <p>파일 검색 때 제외하고 싶은 경로나 추가하고 싶은 경로 <del>(이제 공유 폴더 다 뒤졌다)</del> 또한 제거/추가 할 수 있다.</p> <p>다음은 자주 사용하는 tool 단축키</p> <ul> <li><code class="language-plaintext highlighter-rouge">Tab</code>:검색창과 검색한 결과는 이동 가능</li> <li><code class="language-plaintext highlighter-rouge">Enter</code>: 열고 싶은 파일 열기</li> <li><code class="language-plaintext highlighter-rouge">Ctrl</code>+<code class="language-plaintext highlighter-rouge">Enter</code>: 파일의 경로 열기</li> <li><code class="language-plaintext highlighter-rouge">Ctrl</code>+<code class="language-plaintext highlighter-rouge">Shift</code>+<code class="language-plaintext highlighter-rouge">C</code>: Copy full name(path) to clipboard</li> </ul> <h2 id="onedrive-cloud">Onedrive :cloud:</h2> <p>Onedrive는 사실 SharePoint의 다른 이름이다. 즉, 연결된 SharePoint의(웹) 사이트의 폴더들을 로컬 onedrive에 연동할 수 있다. Sharepoint에서 documents 탭으로 이동하여 Add shortcut to Onedrive를 통해 연동할 수 있다. (창이 작으면 … 아이콘을 클릭하면 보임)</p> <p>연동시킨 뒤 everything에서 동기화 시키고 싶은 onedrive의 경로를 탐색하는 범위에 등록하면 SharePoint에 올라간 파일을 쉽게 search할 수 있게 된다. <del>(이제 회사 퇴사자들의 자료를 털어볼까)</del></p> <p>Sharepoint뿐만 아니라 Teams안에 있는 채널들에 대한 파일들 또한 동기화가 가능하다. Add shortcut to Onedrive를 통해 동기화 시켜두도록 하자.</p> <p>파일을 실수로 삭제하거나 복원하고 싶을 때는 sharepoint로 접속해 bin에 있는 항목을 살려주거나, 파일 우클릭 후 version history를 통해 복원 가능하다.</p> <h2 id="gitextension-arrows_clockwise">GitExtension :arrows_clockwise:</h2> <p>Windows에서 사용할 수 있는 툴. 편한 UI, 로컬에 설치된 git repository 관리, 파일 별 history 추적, 나름(?) 편리한 diff 등이 장점이다.</p> <p>(diff가 보기 좋긴해도, vscode에서 제공하는 source compare 보다 가독성이 떨어지긴 함.. )</p> <p>git commit template을 작성할 수 있어 formatting이 요구되는 commit에 사용하기 적합한 듯.</p> <p>단점은 gerrit이랑 사용하면 좀 꼬이는 듯.. gerrit 커맨드랑 호환하려면 따로 plugin을 설치해야하는 것으로 보임</p> <p>생각난 김에 적는 gerrit push 키워드,, git push origin HEAD:refs/for/master 위 커맨드가 안 먹히면 msg-hook을 통한 clone을 안 했기 때문임. (간접적으로 cloned_repo/.git/hooks/commit-msg 파일 유무로 msg-hook이 되있는지 체크 가능) gerrit은 commit score와 verify 조건을 만족할 때까지 커밋을 계속 수정해서 올리는게 일반적이므로, git commit –amend를 상당히 자주 사용하게 된다 :fearful:</p> <h2 id="mobaxterm-computer">MobaXterm :computer:</h2> <p>여러가지 기능이 있는 터미널 이다. 주로 SSH 목적으로 쓰는데, 가장 편한건 SSH로 접속했을 때 왼쪽에 file explorer 창을 띄워주는 기능이다. 때문에 scp 같은 명령어 없이 drag&amp;drop으로 파일을 손 쉽게 복사/붙여넣기 할 수 있다.</p> <p>또 한가지 업무상 ssh를 여러번 접속해야하는 경우가 많은데, 자주 들어가는 ssh에 session에 ID/PW를 저장할 수 있어 편하다. 그리고 ssh gateway목적으로 ssh에 접속한 후 해당 네트워크에서 연결된 다른 ssh로 점프할 수 있는 기능까지 있어 편리하다.</p> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/20240530_mobaXterm.JPG-480.webp 480w,/assets/img/20240530_mobaXterm.JPG-800.webp 800w,/assets/img/20240530_mobaXterm.JPG-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/20240530_mobaXterm.JPG" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <h2 id="umlet-pencil2">UMLet :pencil2:</h2> <p>블로그에 올리는 UML은 이 툴을 통해 그리고 있다. UML로 유명한 Enterprise architecture(EA)는 유로이고 또 굉장히 사용자 친화적이지 않기 때문에.. 개인적으로 별로 좋아하는 툴은 아니다. 반면 UMLet는 말이 UML이지 사실 사용자가 맘대로 드로잉이 가능하다. UML을 정확히 알고 쓰는게 아닌 입장에서 이 만한 툴이 없는 것 같다. 익숙해지면 사용하기 편한 툴이다. (요즘은 VScode extension으로도 지원되던데, 아무래도 오리지널이 편한듯)</p> <p>예쁘게 그리려고하면 대신 엄청난 노가다가 필요한게 단점.</p> <h2 id="zoomit-gem">ZoomIt :gem:</h2> <p>MS 소개 페이지에 있을 정도로 유명한 utility tool이다. 기능은 화면 확대, 스크린에 펜슬로 드로잉 가능, 화면 녹화 기능등 다양하다. 이 툴을 통해서 스크린에다가 드로잉 하거나, 글자 등을 쓸 수 있어서 화상으로 일하면서 화면 공유 하는 일이 많은 직종에 강추하는 툴이다.</p> <p>기본 키 매핑은 Ctrl + 1, Ctrl +2 등으로 되어 있으며, 사용자 메뉴얼은 <a href="https://learn.microsoft.com/ko-kr/sysinternals/downloads/zoomit">MS내 툴 소개 페이지</a>로 대체한다.</p> <p>자주 쓰는 기능은</p> <ul> <li>스크린에 드로잉(<code class="language-plaintext highlighter-rouge">Ctrl</code>+<code class="language-plaintext highlighter-rouge">2</code>)</li> <li>드로잉 기능 켜졌을 때 글자 입력(<code class="language-plaintext highlighter-rouge">Shirt</code>+<code class="language-plaintext highlighter-rouge">t</code>)</li> <li>칠판 모드 <code class="language-plaintext highlighter-rouge">W</code> or <code class="language-plaintext highlighter-rouge">K</code></li> <li>색 변경 <code class="language-plaintext highlighter-rouge">R, G, B</code></li> <li>클립보드에 복사 <code class="language-plaintext highlighter-rouge">Ctrl</code>+<code class="language-plaintext highlighter-rouge">C</code> or <code class="language-plaintext highlighter-rouge">Ctrl</code>+<code class="language-plaintext highlighter-rouge">Shirt</code>+<code class="language-plaintext highlighter-rouge">C</code>.</li> </ul> <h2 id="windows-heavy_check_mark">Windows :heavy_check_mark:</h2> <p>툴의 영역은 아닌데 Windows OS에서 사용하는 꿀 커맨드를 소개한다.</p> <ul> <li><code class="language-plaintext highlighter-rouge">Win</code>+<code class="language-plaintext highlighter-rouge">V</code>: 복사했던 내용을 히스토리 패널로 불러온다. 이 기능을 알고 나면 절대 이전으로 못 돌아갈 정도로 편한 기능</li> <li><code class="language-plaintext highlighter-rouge">Ctrl</code>+<code class="language-plaintext highlighter-rouge">Alt</code>+<code class="language-plaintext highlighter-rouge">V</code>: 복사한 문자 서식/포맷 없이 붙여 넣기.</li> <li><code class="language-plaintext highlighter-rouge">Shift</code>+<code class="language-plaintext highlighter-rouge">Enter</code>: Confluence나 wiki 혹은 MS-word 등에서 엔터는 줄 나눔을 뜻한다. 하지만 여기에 shift를 붙이면 간격 없이 줄 나눔을 할 수 있는데, 이러면 글 쓸 때 굉장히 깔끔해진다.</li> </ul> <div class="col-sm-5 mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/20240530_shiftEnter.JPG-480.webp 480w,/assets/img/20240530_shiftEnter.JPG-800.webp 800w,/assets/img/20240530_shiftEnter.JPG-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/20240530_shiftEnter.JPG" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <ul> <li><code class="language-plaintext highlighter-rouge">Ctrl</code>+<code class="language-plaintext highlighter-rouge">Shift</code> 누른채로 Drag: 텍스트 중간에서 드래그 하고 싶을 때 사용</li> </ul> <div class="col-sm-5 mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/20240530_CtrlShiftDrag.JPG-480.webp 480w,/assets/img/20240530_CtrlShiftDrag.JPG-800.webp 800w,/assets/img/20240530_CtrlShiftDrag.JPG-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/20240530_CtrlShiftDrag.JPG" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <p><code class="language-plaintext highlighter-rouge">Win</code>+<code class="language-plaintext highlighter-rouge">숫자</code>: 작업표시줄에 있는 프로그램을 실행시킨다.</p> <h2 id="beyond-compare-traffic_light">Beyond compare :traffic_light:</h2> <p>파일이나 폴더 자체를 1:1로 비교할 때 사용하는 툴. 아쉽게도 유로이나 왠만하면 회사에서 사준다.</p> <p>없을 때는 notepad++에서 plugin에 compare로 볼 수 있는데 기능이 다소 아쉬운 편이다.</p> <h2 id="vscode-vs">VScode :vs:</h2> <p>말이 없는 G.O.A.T :goat:</p> <p>사용하고 있는 extension으로는</p> <ul> <li>project manager: workspace 관리에 좋다</li> <li>git graph: git terminal 커맨드로 고통받는 스타일이 아니기 때문에 이툴로 git을 관리한다</li> <li>remote-ssh: 매 번 SSH 접속할 때 ID/PW 입력에 고통받는 다면 꼭 ID/PW 설정을 해주도록 하자</li> <li>copilot: 잘 쓰면 신세계. compiler 에러, polyspace coding rule violation 등 여러상황에서 <code class="language-plaintext highlighter-rouge">해줘</code>하면 거의 찾아내주는 듯</li> <li>doxygen documentation generator: 함수 헤더에 doxygen 스타일로 코멘트를 달 수 있다.</li> </ul> <p>커스터마이징 한 vscode는 새 개발환경 구축할 때 마다 번거러운데 설정 동기화를 해놓으면 편하다.</p> <p>예전에는 extension으로 설정 동기화를 해주었는데, 요즘은 VScode 내에서 동기화해주는 기능이 있어 이를 사용하는 중</p> <p>자주 사용하는 단축키</p> <ul> <li><code class="language-plaintext highlighter-rouge">Ctrl</code> + <code class="language-plaintext highlighter-rouge">p</code> : workspace내에 파일 검색</li> <li><code class="language-plaintext highlighter-rouge">Ctrl</code> + <code class="language-plaintext highlighter-rouge">Shift</code> + <code class="language-plaintext highlighter-rouge">f</code>: workspace 내에 단어 검색. 확장자 별로 files to include/exclude 설정 가능</li> <li><code class="language-plaintext highlighter-rouge">F1</code>: extension에서 파생되는 기능시 사용 ex. F1 후 git graph 검색하여 열기 기능</li> <li><code class="language-plaintext highlighter-rouge">F12</code>: Go to definition</li> <li><code class="language-plaintext highlighter-rouge">Ctrl</code>+` : 터미널 open/close</li> </ul> <h2 id="linux-penguin">Linux :penguin:</h2> <p>-<code class="language-plaintext highlighter-rouge">Ctrl</code>+<code class="language-plaintext highlighter-rouge">R</code> : bash에서 해당 커맨드 입력 후, 타이핑 시 bash 히스토리에서 사용되었던 가장 유사한 커맨드 출력<br/> (Powershell에서도 똑같이 동작)</p> <p>GREP: A: After, B: Before, C:In between</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">grep</span> <span class="nt">-A</span> 3 &lt;keyword&gt; &lt;file&gt; <span class="c"># 매칭되는 keyword로부터 밑의 3줄을 추가로 출력함</span>
</code></pre></div></div> <p>-r:recursive search to downstream directories -n:line number</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">grep</span> <span class="nt">-rn</span> &lt;keyword&gt; <span class="k">*</span> <span class="c">#현재 디렉터리의 모든 하위 경로에 있는 파일에서 매칭되는 keyword 있으면 파일과 라인번호 출력</span>
</code></pre></div></div> <p>XXD: binary 포맷 파일 다룰 때 사용</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>xxd <span class="nt">-c</span> 8 &lt;file&gt; <span class="c"># Number of character in a row</span>
xxd <span class="nt">-p</span> &lt;file&gt;   <span class="c"># Print wihtout format</span>
xxd <span class="nt">-u</span> &lt;file&gt;   <span class="c"># Print capital character</span>
</code></pre></div></div> <p>LLD: 사용자 빌드환경에서 사용했던 .so 파일이 target device에서 지원되는지 아닌지 확인할 때 사용함</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lld &lt;.bin file&gt; <span class="c"># Print all relavant .so(shared object) file</span>
</code></pre></div></div> <p>잡다한 커맨드</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ldconfig <span class="nt">-p</span> <span class="c"># library가 있는 경로 출력</span>
which &lt;binary file&gt; <span class="c"># 커맨드가 ~/.local/bin에 있는지 긴가민가 할 때, 파일 위치어딘지 출력하는 커맨드</span>
<span class="nb">cat</span> <span class="sb">`</span>which &lt;vinary file&gt;<span class="sb">`</span> <span class="c"># ``을 붙이면 커맨드 실행결과를 터미널에 파라미터로 리턴 한다.</span>
                          <span class="c"># 예시는 cat을 썻으므로 해당 파일을 터미널에 출력</span>
pinky <span class="c">#최근 접속한 기록 출력</span>
ps ax | <span class="nb">grep </span>sshd <span class="c"># ssh server에 접속해 있는 현재 사용자 출력</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="개발"/><category term="tool"/><category term="sidebar"/><summary type="html"><![CDATA[사용하고 있는 tool에 대해 소개합니다]]></summary></entry><entry><title type="html">인증서는 어떻게 verification될까?</title><link href="https://sweetdrake.github.io/blog/2024/certificate-verification/" rel="alternate" type="text/html" title="인증서는 어떻게 verification될까?"/><published>2024-05-29T10:14:00+00:00</published><updated>2024-05-29T10:14:00+00:00</updated><id>https://sweetdrake.github.io/blog/2024/certificate-verification</id><content type="html" xml:base="https://sweetdrake.github.io/blog/2024/certificate-verification/"><![CDATA[<p>준비물 openssl이 깔린 환경 (openssl 설치하는 건 생략합니다.. 설치는 cgywin, git bash, wsl, dockerhub 등 자유롭게)</p> <h2 id="인증서는-배웠는데-실전에서-인증-관계를-잘-모르겠어요">인증서는 배웠는데, 실전에서 인증 관계를 잘 모르겠어요!</h2> <p>저 같은 분들이 많을 거라고 생각합니다. PKI를 텍스트로 배우면 인증 flow가 잘 와닿지가 않는 것 같습니다. (개인 경험) 그래서 openssl을 통해 Root인증서, intermediate인증서, 마지막 leaf 인증서를 만들어보고 leaf에서 intermediate가 인증한 인증서를 openssl command를 통해서 검증하면서 PKI를 이해 해봅시다.</p> <p>예제를 통해 생성할 PKI 구조는 다음과 같습니다.</p> <p>예제에 사용한 파일들은 <a href="https://github.com/sweetdrake/certificate-verification">github</a>에 올려두었습니다.</p> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/240529_PKI%20hierarchy.JPG-480.webp 480w,/assets/img/240529_PKI%20hierarchy.JPG-800.webp 800w,/assets/img/240529_PKI%20hierarchy.JPG-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/240529_PKI%20hierarchy.JPG" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <h3 id="키-만들기">키 만들기</h3> <p>각 도메인(rootCA, intermediate, leaf)을 대표하는 3개의 키를 생성합니다.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>openssl genrsa <span class="nt">-out</span> rootCA.key 2048
openssl genrsa <span class="nt">-out</span> intermediate.key 2048
openssl genrsa <span class="nt">-out</span> leaf.key 2048
</code></pre></div></div> <h3 id="csr을-통해-인증서-발급하기">CSR을 통해 인증서 발급하기</h3> <p>상위 스트림에게 CSR(Certificate Siging Request)를 요청하여 인증서를 발급받을 수 있습니다. 하지만 최상위 스트림의 경우(root CA) 상위 스트림이 없기 때문에 자기 자신에게 signing request를 보내면 되는데 이는 self-sign이라고 합니다. self-sign의 경우, 상위 스트림에 따로 CSR을 보낼 필요없이 자신의 도메인에서 self-sign하면 됩니다.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># RootCA 도메인에서 self-sign</span>
openssl req <span class="nt">-x509</span> <span class="nt">-new</span> <span class="nt">-nodes</span> <span class="nt">-key</span> rootCA.key <span class="nt">-sha256</span> <span class="nt">-days</span> 1825 <span class="nt">-out</span> rootCA.pem
</code></pre></div></div> <p>CA(Certificate Authority, 인증기관)인 rootCA.pem이 생성되었습니다.</p> <p>이제 intermediate 도메인으로 넘어가보죠, <br/> intermediate 키를 갖고 있는 사용자는 CSR을 생성하여 rootCA에 intermediate 키를 갖는 사용자의 신원을 보증을 부탁하는데(Reference), 보증된 문서는 인증서의 형태로 출력됩니다.</p> <p>생성하는 CSR에는 <code class="language-plaintext highlighter-rouge">intermediate 도메인 사용자에 대한 정보</code>와 <code class="language-plaintext highlighter-rouge">intermediate.key의 public key</code>가 담겨 있습니다. CSR에 사용자에 대한 정보를 실어 보내는 이유는 뭘까요? 만약 Reference목적으로 상위 스트림에게 public key를 전달한다면, 받는 입장에서 이 key가 도대체 누구한테서 전달된 key인지 알 수가 없기 때문입니다. 또한 상위 스트림에서 특정 포맷의 신원 정보를 필터링하여 아무 관계도 없는 제3자의 publicKey를 reference하는 상황도 방지하는 기능도 합니다.</p> <p>다시 본론으로 돌아와서, CSR을 상위 스트림에 보내는 이유는 앞서 말한대로, 전달하는 publicKey는 상위 스트림(여기서는 rootCA)을 대리인으로 세워 신원을 보증받기 위함입니다. rootCA라는 대리인이 보증하는 인증서는(정확하게 말하면 인증서 포맷안에 패키징된 하위 스트림의 publicKey)는 rootCA 대리인을 믿고 있는 사용자들(바꿔 말하면 rootCA의 publicKey를 갖고 있는 사용자들)이 믿고 쓸 수 있을 겁니다.</p> <p>물론 믿는다고 해서, 인증서 검증하는 단계가 생략되지는 않습니다. 자세한 검증 단계에 대한 설명은 뒤에서 살펴보고, 우선 하위 스트림에서 생성할 수 있는 CSR과 상위 스트림으로부터 생성되는 인증서부터 만들고 설명해 보죠.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># intermediate 도메인에서 CSR생성</span>
openssl req <span class="nt">-new</span> <span class="nt">-sha256</span> <span class="nt">-key</span> intermediate.key <span class="nt">-out</span> intermediate.csr

<span class="c"># RootCA도메인으로 CSR이 전달되어 rootCA가 reference하는 intermediate.pem 인증서가 발급됨</span>
openssl x509 <span class="nt">-req</span> <span class="nt">-in</span> intermediate.csr <span class="nt">-CA</span> rootCA.pem <span class="nt">-CAkey</span> rootCA.key <span class="nt">-CAcreateserial</span> <span class="nt">-out</span> intermediate.pem <span class="nt">-days</span> 365 <span class="nt">-sha256</span> <span class="nt">-extfile</span> &lt;<span class="o">(</span><span class="nb">echo</span> <span class="s2">"basicConstraints=critical,CA:TRUE"</span><span class="o">)</span>
</code></pre></div></div> <p>rootCA의 인증을 받은 인증서를 intermediate.pem가 생겼습니다. 하지만 인증서를 검증없이 사용할 수 있을까요? 인증서를 사용한다는 의미는 인증서 내부에 있는 publicKey를 사용한다는 뜻 입니다. 사용하고자 하는 publicKey를 무턱대고 쓸 수 없으니 신원을 검사할 필요가 있는데, 이를 상위 스트림이 사전 배포한 publicKey를 통해서 인증서 꼬리에 붙은 서명(Signature)을 검증하여 publicKey에 대한 신원을 확인할 수 있습니다. 물론 검증 과정의 선행으로 상위 스트림의 publicKey가 사용자에게 안전하게 전달된 것을 가정합니다.</p> <p>이를 그림으로 표현하면 아래와 같습니다. 예제에 등장하지 않는 intermediate B가 나왔는데 intermediate A의 publicKey를 생성하고 싶어하는 도메인으로 이해하면 되겠습니다.</p> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/240529_HowCertificateCanBeVerified.JPG-480.webp 480w,/assets/img/240529_HowCertificateCanBeVerified.JPG-800.webp 800w,/assets/img/240529_HowCertificateCanBeVerified.JPG-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/240529_HowCertificateCanBeVerified.JPG" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <p>자세한 인증서 검증 과정을 서술하면, <code class="language-plaintext highlighter-rouge">(A)인증서 꼬리에 붙은 서명을 상위스트림의 publicKey로 복호화한 값에 해쉬함수를 적용해 얻은 해쉬 값</code>과 <code class="language-plaintext highlighter-rouge">(B)서명을 제외한 인증서 자체 값에 해쉬함수를 적용해 얻은 해쉬</code>를 비교하여 서로 같으면 인증서에 담긴 publicKey의 신원이 확인되어 해당 publicKey를 사용해도 된다는 것이고, 반대의 경우 상위 스트림의 인증을 받지않은 사용자 신원으로 판명되어 사용하면 안된다는 것 입니다.</p> <p>위 예제로 보면 intermediate 도메인에 있는 사용자가 rootCA에 인증요청(CSR)을 통해 얻은 intermediate certificate는 rootCA의 publicKey를 갖고 있는 다른 사용자들에게 유효한 셈입니다.</p> <p>꽤나 복잡한데요, 위에 적어 놓은 검증 과정은 차차 나올테니 걱정마세요.</p> <p>계속해서 leaf 사용자 인증서도 생성해보겠습니다.</p> <p>다음으로 생성할 leaf 인증서는 intermediate를 상위 스트림으로 갖는 인증서로 생성하겠습니다. 생성한 CSR(leaf.csr)은 외부에 노출된 환경에서 intermediate 도메인으로 전달되며(publicKey는 노출되어도 상관 없습니다!), CSR에 대한 sign은 intermediate의 private key를 통해 이루어지고 이 결과물을 <code class="language-plaintext highlighter-rouge">leaf 사용자 인증서(leaf.pem)</code>라고 하겠습니다.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>openssl req <span class="nt">-new</span> <span class="nt">-sha256</span> <span class="nt">-key</span> leaf.key <span class="nt">-out</span> leaf.csr <span class="c"># Generate leaf CSR</span>
openssl x509 <span class="nt">-req</span> <span class="nt">-in</span> leaf.csr <span class="nt">-CA</span> intermediate.pem <span class="nt">-CAkey</span> intermediate.key <span class="nt">-CAcreateserial</span> <span class="nt">-out</span> leaf.pem <span class="nt">-days</span> 365 <span class="nt">-sha256</span> //Sign leaf CSR by intermediate
</code></pre></div></div> <p>여기서 -basicConstraints=critical,CA:TRUE이 생략된 채로 leaf 인증서가 만들어 지는데요, 이 의미는 leaf인증서를 통해 더이상 하위 스트림의 인증서를 만들지 않겠다는 뜻이 됩니다.</p> <p>예제를 통해 만든 인증서 chain 구조를 좀 더 자세히 나타내면 아래와 같습니다.</p> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/240529_PKI%20hierarchy(Detail).JPG-480.webp 480w,/assets/img/240529_PKI%20hierarchy(Detail).JPG-800.webp 800w,/assets/img/240529_PKI%20hierarchy(Detail).JPG-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/240529_PKI%20hierarchy(Detail).JPG" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <h3 id="인증서-검증하기">인증서 검증하기</h3> <p>인증서를 openssl을 통해 비교해보겠습니다. openssl에서 인증서 검증은 인증서 체인을 검증하기 때문에 rootCA인증서와 중간 단계인 intermediate인증서를 하나로 이어(cat=concatenate) trustChain인증서를 생성하겠습니다.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat </span>rootCA.pem intermediate.pem <span class="o">&gt;</span> trustChain.pem
</code></pre></div></div> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>openssl verify <span class="nt">-CAfile</span> rootCA.pem intermediate.pem  <span class="c"># Case1) Verify OK</span>
openssl verify <span class="nt">-CAfile</span> trustChain.pem leaf.pem      <span class="c"># Case2) Verify OK</span>
openssl verify <span class="nt">-CAfile</span> rootCA.pem leaf.pem       <span class="c"># Case3) Verify NOK</span>
openssl verify <span class="nt">-CAfile</span> intermediate.pem leaf.pem <span class="c"># Case4) Verify NOK</span>
</code></pre></div></div> <p>위 1번째 경우, intermediate.pem의 상위 스트림이 root.pem이 맞는지 확인 합니다. OK가 나왔을 겁니다. 2번째 경우, leaf.pem의 상위 스트림이 root.pem, intermediate.pem으로 이루어진 trustChain.pem이 맞는지 확인합니다. openssl에서 상위 스트림에 대한 확인은 연결된 모든 상위 스트림의 인증서를 검증합니다. 꼭 openssl이라서 이런 건 아니고 논리적으로도 모든 상위 스트림을 비교하는게 맞기 때문에 이러는 겁니다.</p> <p>하지만 이런 의문을 갖을 순 있죠, leaf의 상위 스트림이 intermediate 혹은 rootCA인데 이 경우에도 부분적으로 되어야 하는건 아닌가?</p> <p>예제 3번째 경우, leaf의 최상위 스트림이 rootCA이지만, verify는 실패하는데 이는 intermediate에 대한 정보가 없기 때문입니다. 왜냐하면 leaf 인증서의 경우 intermediate.key가 sign을 했기 때문에 rootCA가 갖고있는 publicKey로는 leaf인증서 꼬리에 달린 signature를 검증할 수 없기 때문입니다.</p> <p>하지만 4번째 경우, leaf의 바로 직전 상위 스트림이 intermediate인데 왜 출력되는 verify결과는 error일까요? 부분적으로 leaf 인증서 꼬리에 달린 signature에 대한 검증은 intermediate의 publicKey로 인증되지만 거시적으로 볼 때 intermediate 인증서 또한 검증하는게 더 안전하기 때문에, 최상위 정보가 없는 인증서에 대한 검증은 openssl에서는 error라고 판단하기 때문입니다.</p> <h3 id="raw-level로-인증서-검증하기">Raw level로 인증서 검증하기</h3> <p>4번째 경우, leaf인증서가 intermediate를 통해 발급되었음을 검증하는 일은 불가능한 일 일까요? 위에서 인증서 검증 과정은 인증서 꼬리에 붙은 <code class="language-plaintext highlighter-rouge">(A)인증서 꼬리에 붙은 서명을 상위스트림의 publicKey로 복호화한 값에 해쉬함수를 적용해 얻은 해쉬 값</code>과 <code class="language-plaintext highlighter-rouge">(B)서명을 제외한 인증서 자체 값에 해쉬함수를 적용해 얻은 해쉬</code>를 통해 이루어 진다고 했는데요. 한 번 그대로 만들어 보겠습니다.</p> <h4 id="b인증서-자체에-대한-해쉬값-얻기">(B)인증서 자체에 대한 해쉬값 얻기</h4> <p>(B)의 경우부터 살펴보죠, 서명을 제외한 인증서 자체 값은 어떻게 뽑아 낼까요? 그 전에 왜 인증서 자체 값이 필요한지 살펴보면, 상위 스트림 privateKey이 인증서를 만들 때, 사인한 서명값 뒤에 붙이는데, 서명을 만드는 방법은 사실 인증서에 대한 암호화를 사인이라고 부르기 때문입니다.</p> <p>따라서 서명 검증을 한다는 뜻은 곧 서명에 대한 복호화를 의미하게 되는데, 복호화된 값이 인증서를 사인(암호화)하기 전 값과 정확하게 일치하면 암호화와 복호화에 사용된 비대칭키가 같은 쌍인지 아닌지를 검증할 수 있기 때문입니다. 그림으로 보면 더 쉽죠, 아래 그림에서 보자면 plainText는 인증서 자체 값과 대응합니다.</p> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/240529_AsymmetricKeySignVerify.JPG-480.webp 480w,/assets/img/240529_AsymmetricKeySignVerify.JPG-800.webp 800w,/assets/img/240529_AsymmetricKeySignVerify.JPG-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/240529_AsymmetricKeySignVerify.JPG" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <p>물론 인증서 자체 값에 바로 사인(암호화)를 적용하진 않습니다. 암호화에 앞서 길이를 평준화할 목적과 어떤 값을 사인을 어떤 대상으로 했는지 쉽게 못 알아차릴 목적으로 해쉬 함수를 적용 합니다. 이제 인증서 자체 값(PlainText)을 뽑아내고, 해쉬까지 적용해 보겠습니다.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 인증서에서 sign할 때 사용되었던 plainText 뽑아내기</span>
openssl asn1parse <span class="nt">-inform</span> PEM <span class="nt">-in</span> leaf.pem <span class="nt">-strparse</span> 4 <span class="nt">-out</span> leef.val.der

<span class="c"># 1) PlaintText에 해쉬함수 적용, Binary file로 보고 싶으면 경우</span>
openssl dgst <span class="nt">-sha256</span> <span class="nt">-binary</span> leaf.val.der <span class="o">&gt;</span> leaf.val.der.dgst

<span class="c"># 2) PlaintText에 해쉬함수 적용, 커맨드 창으로 hash 보고 싶은 경우</span>
openssl dgst <span class="nt">-sha256</span> leaf.val.der <span class="nt">-out</span> leaf.val.der.dgst
</code></pre></div></div> <p>저는 (B)의 값으로 da88de0c48c81d92e6e16a026460baad2e5ed0808eb6e5e9d3ab8f8ee2c52fd5의 해쉬값을 얻게 되었습니다. 이 값이 이 후에 나올 과정을 통해서 똑같이 생성되는지 살펴보도록 하죠.</p> <h4 id="a서명을-복호화한-값에서-해쉬값-얻기">(A)서명을 복호화한 값에서 해쉬값 얻기</h4> <p>이제 (A)값을 얻어 볼까요. 먼저 leaf 인증서의 서명을 뽑아보겠습니다. 아래 긴 옵션 없이 -noout까지 출력하셔도 됩니다.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># leaf 인증서 꼬리부분인 서명만 출력하기</span>
<span class="nv">$ </span>openssl x509 <span class="nt">-in</span> leaf.pem <span class="nt">-text</span> <span class="nt">-noout</span> <span class="nt">-certopt</span> ca_default <span class="nt">-certopt</span> no_validity <span class="nt">-certopt</span> no_serial <span class="nt">-certopt</span> no_subject <span class="nt">-certopt</span> no_extensions <span class="nt">-certopt</span> no_signame | <span class="nb">sed </span>s/://g
<span class="c"># &gt;&gt; output</span>
    Signature Algorithm sha256WithRSAEncryption
         16dc33615c15c2a7ab4e305c3f9bd42c508a
         f4b6021611ddd3261f279a154b8164e42340
         8d56f9efa954e6f5c1f7d85b1b4dd1cd5576
         adc706b21086232f7884d390007804346e04
         4696b1c30e31537b7fcb28f2f6edb3a2799e
         d3bfe001a7162000fd449d933321bb8dabaa
         9d224f761b65da8fa7c672539c55aaf0be0d
         cd320a5ac48f23e1ee48e7b0c7fca8f2c2e3
         fc92f565e051dbbc3636ed120226edccdae9
         a2a7d75b369b595496b03adb31cf7f26edb3
         718ba92b1183a582c4cc551e6db7e6bc37a4
         40ca40c7ffaaac41a80737c9c41ed50082eb
         e925f27e0bde984c7bf86acb474d57ee2114
         c0bbefdf6a2b9362e1a4272021bfff6690af
         ae56341c
</code></pre></div></div> <p>이번엔 publicKey가 필요합니다. 필요한 이유는 서명을 검증(복호화)할 때는, 암호화 출력값인 서명에 publicKey를 사용하면 복호화할 수 있기 때문입니다. publicKey를 얻기위해서는 leaf.pem 인증서를 서명할 때 사용한, intermediate.key private키의 반대쪽 쌍인 publicKey가 필요합니다. leaf 도메인 입장에서 바로 직전 상위 스트림의 인증서(intermediate.pem)가 있다고 가정합니다. intermediate.pem에서 publicKey는 아래 커맨드로 뽑아낼 수 있죠.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c"># intermediate 인증서에 담긴 publicKey 출력(RSA이므로 modulus만 뽑아내겠습니다)</span>
 openssl x509 <span class="nt">-modulus</span> <span class="nt">-noout</span> &lt; intermediate.pem | <span class="nb">sed </span>s/Modulus<span class="o">=</span>//
 <span class="c"># &gt;&gt; output</span>
 b0aa11aae1e641c54abc1f3bdf52034fd7d497ed11045ad1f8eb78f2c38b91388a0401f422628e794904c2942a6d4c71f997be6e95a1135ea0fe1f1165c6619c86aa342d49f7b528443205b88110208ee0968a367225523a212f326de532a92c924b978ae1677f394403c7e9eda856a533d79ade889936ca2e69d441fe98dd5d5d6b5de1cb168a15526de39839de544906898e546e71ae2bea8ea6092a4edb3ef9186e9b1e906645ae33f6d32e670baba0b787968f6701e66a3d38c1d8970f868dd161f4abbe8e6f45b6a99121feb8c0d8f65cb945e60ffe1c4617f3c74a7b5894064bd136abd408fa98133604a969134aa3907df916b6d810d437b00571fd81
</code></pre></div></div> <p>자 이제 서명값을 검증(복호화) 해보겠습니다. 아래는 파이썬으로 만든 RSA 복호화 코드입니다.</p> <p>(RSA 복호화가 겨우 1줄.. ㅋㅋ)</p> <p>위에서 얻은 서명과 공개키를 아래와 같이 넣어주었습니다.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">modulus</span><span class="o">=</span><span class="sh">"</span><span class="s">b0aa11aae1e641c54abc1f3bdf52034fd7d497ed11045ad1f8eb78f2c38b91388a0401f422628e794904c2942a6d4c71f997be6e95a1135ea0fe1f1165c6619c86aa342d49f7b528443205b88110208ee0968a367225523a212f326de532a92c924b978ae1677f394403c7e9eda856a533d79ade889936ca2e69d441fe98dd5d5d6b5de1cb168a15526de39839de544906898e546e71ae2bea8ea6092a4edb3ef9186e9b1e906645ae33f6d32e670baba0b787968f6701e66a3d38c1d8970f868dd161f4abbe8e6f45b6a99121feb8c0d8f65cb945e60ffe1c4617f3c74a7b5894064bd136abd408fa98133604a969134aa3907df916b6d810d437b00571fd81</span><span class="sh">"</span>
<span class="n">exponent</span><span class="o">=</span><span class="mi">65537</span>
<span class="n">signature</span> <span class="o">=</span><span class="sh">"</span><span class="s">16dc33615c15c2a7ab4e305c3f9bd42c508af4b6021611ddd3261f279a154b8164e423408d56f9efa954e6f5c1f7d85b1b4dd1cd5576adc706b21086232f7884d390007804346e044696b1c30e31537b7fcb28f2f6edb3a2799ed3bfe001a7162000fd449d933321bb8dabaa9d224f761b65da8fa7c672539c55aaf0be0dcd320a5ac48f23e1ee48e7b0c7fca8f2c2e3fc92f565e051dbbc3636ed120226edccdae9a2a7d75b369b595496b03adb31cf7f26edb3718ba92b1183a582c4cc551e6db7e6bc37a440ca40c7ffaaac41a80737c9c41ed50082ebe925f27e0bde984c7bf86acb474d57ee2114c0bbefdf6a2b9362e1a4272021bfff6690afae56341c</span><span class="sh">"</span>
<span class="c1"># Decrypt RSA: (sign ** public_exp) % modulus
</span><span class="n">padded_hash</span> <span class="o">=</span> <span class="nf">hex</span><span class="p">(</span><span class="nf">pow</span><span class="p">(</span><span class="nf">int</span><span class="p">(</span><span class="n">signature</span><span class="p">,</span> <span class="mi">16</span><span class="p">),</span> <span class="n">exponent</span><span class="p">,</span> <span class="nf">int</span><span class="p">(</span><span class="n">modulus</span><span class="p">,</span> <span class="mi">16</span><span class="p">)))</span>
<span class="nf">print</span><span class="p">(</span><span class="n">padded_hash</span><span class="p">)</span>

<span class="c1">#Output
#0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff003031300d060960864801650304020105000420da88de0c48c81d92e6e16a026460baad2e5ed0808eb6e5e9d3ab8f8ee2c52fd5
</span></code></pre></div></div> <p>서명을 복호화 했더니 0x1fffff…인 값인 어떤 포맷된 결과가 출력되었습니다. 이는 RSA_PKCS_v1_5 포맷형식의 sign이 적용된 서명을 복호화 했기 때문인데, openssl을 통한 인증서 생성시 기본 설정값은 RSA-PKCS_v1_5를 통해서 sign을 하게끔 되어있기 때문입니다. RSA_PKCS_v1_5는 0x1ffffff…ffff..00 Hash-identifier..hashValue의 형태로 encoding하게끔 되어있습니다. 여기서 3031300d060960864801650304020105000420는 <a href="https://datatracker.ietf.org/doc/html/rfc8017#section-9.2">RSA PKCS_v1_5</a> 에서 정의하는 SHA256에 대한 hash identifier입니다. 저희에게는 hash identifier 뒤에 위치하는 H(hash)da88de0c48c81d92e6e16a026460baad2e5ed0808eb6e5e9d3ab8f8ee2c52fd5값이 의미가 있죠</p> <p>자 그러면 방금 과정을 통해 <code class="language-plaintext highlighter-rouge">(A)인증서 꼬리에 붙은 서명을 상위스트림의 publicKey로 복호화한 값에 해쉬함수를 적용해 얻은 해쉬 값</code>인 da88de0c48c81d92e6e16a026460baad2e5ed0808eb6e5e9d3ab8f8ee2c52fd5를 얻었습니다. ‘Raw level로 인증서 검증하기’ 맨 처음 과정에서 얻은 <code class="language-plaintext highlighter-rouge">(B)서명을 제외한 인증서 자체 값에 해쉬함수를 적용해 얻은 해쉬</code>는 어떤 값이였나요? da88de0c48c81d92e6e16a026460baad2e5ed0808eb6e5e9d3ab8f8ee2c52fd5가 출력되었습니다.</p> <p>따라서 본 목적이였던 leaf 인증서의 상위 스트림이 intermediate 인증서가 맞는지 아닌지에 대한 검증은 위 (A)와 (B)가 서로 같기 때문에 인증서 검증이 완료되었다고 볼 수 있겠습니다.</p>]]></content><author><name></name></author><category term="개발"/><category term="보안"/><category term="sidebar"/><summary type="html"><![CDATA[openssl을 통해서 인증서를 verification 해봅시다]]></summary></entry><entry><title type="html">Displaying External Posts on Your al-folio Blog</title><link href="https://sweetdrake.github.io/blog/2022/displaying-external-posts-on-your-al-folio-blog/" rel="alternate" type="text/html" title="Displaying External Posts on Your al-folio Blog"/><published>2022-04-23T23:20:09+00:00</published><updated>2022-04-23T23:20:09+00:00</updated><id>https://sweetdrake.github.io/blog/2022/displaying-external-posts-on-your-al-folio-blog</id><content type="html" xml:base="https://sweetdrake.github.io/blog/2022/displaying-external-posts-on-your-al-folio-blog/"><![CDATA[]]></content><author><name></name></author></entry></feed>